> https://leetcode.com/problems/count-special-triplets

## Bài toán

```
You are given an integer array nums. 

A special triplet is defined as a triplet of indices (i, j, k) such that: 
- 0 <= i < j < k < n, where n = nums.length 
- nums[i] == nums[j] * 2 
- nums[k] == nums[j] * 2 

Return the total number of special triplets in the array. Since the answer may be large, return it modulo 10^9 + 7.
```

## Điều kiện
- 3 <= n == nums.length <= 10^5
- 0 <= nums[i] <= 10^5  

## Tóm tắt

- Ta cần đếm số bộ ba (i, j, k) sao cho:
    - i < j < k
    - nums[i] = 2 * nums[j]
    - nums[k] = 2 * nums[j]

- Nói cách khác:
    - Chọn một vị trí **j** với giá trị `x = nums[j]`
    - Các vị trí **i** ở bên trái **j** phải có giá trị `2x`
    - Các vị trí **k** ở bên phải **j** cũng phải có giá trị `2x`

- Số bộ ba ứng với một **j** cụ thể là: `countLeft[2x] * countRight[2x]`
- Tổng kết quả là: `ans = Σ_j ( countLeft[2 * nums[j]] * countRight[2 * nums[j]] )`

## Nhận xét

- Đếm tần suất toàn mảng:
    - `freq[v] = số lần xuất hiện của giá trị v trong toàn bộ nums`
- Ban đầu:
    - Chưa có gì ở bên trái.
    - Khởi tạo `prev[nums[0]] += 1` và bắt đầu cho `j` chạy từ 1 đến `n-2` (để đảm bảo còn chỗ cho `i` và `k`).
- Với mỗi vị trí `j`:
    - Gọi `x = nums[j]`
    - Giá trị cần cho `i` và `k` là `2x`
    - `countLeft[2x] = prev[2x]` vì **prev** đang lưu số lần xuất hiện của **2x** ở các chỉ số < j.
    - `countRight[2x] = freq[2x] - prev[2x]` vì số lần xuất hiện của **2x** trong toàn bộ nums trừ đi số lần xuất hiện của **2x** ở các chỉ số < j.
    - `ans += countLeft[2x] * countRight[2x]` vì số lượng bộ ba ứng với **j** cụ thể là `countLeft[2x] * countRight[2x]`.
    - `prev[x] += 1`
- Còn một edge case là khi `x == 0`:
    - Lúc đó `2x = 0`, nên chính `nums[j]` cũng có giá trị bằng `2x`
    - Nhưng `j` không được làm chỉ số `k`
    - Do đó phải trừ đi thêm 1 nếu `nums[j] == 0`
- Công thức cuối cùng cho mỗi vị trí `j` là `ans += countLeft[2x] * countRight[2x] - (nums[j] == 0)`
- Kết quả cuối cùng là `ans % (10^9 + 7)`

## Độ phức tạp

- **Thời gian:** Mỗi phần tử được xử lý đúng 1 lần → `O(n)`
- **Bộ nhớ:** map/từ điển → `O(n)` trong trường hợp xấu nhất.

## Mã giả

```
MOD = 1_000_000_007

freq = Counter(nums)
prev = Counter()

n = len(nums)
if n < 3:
    return 0

res = 0

prev[nums[0]] += 1
for j from 1 to n-2:
    x = nums[j]
    target = 2 * x

    leftCount  = prev[target]
    rightCount = freq[target] - prev[target] - (x == 0 ? 1 : 0)

    res += leftCount * rightCount
    res %= MOD

    prev[x] += 1

return res

```

## Code giải

[Python](https://github.com/toan207/Code-And-Milktea/blob/main/Milktea/LeetCode/Code/Python/3583.py), [Golang](https://github.com/toan207/Code-And-Milktea/blob/main/Milktea/LeetCode/Code/Golang/3583.go), [Java](https://github.com/toan207/Code-And-Milktea/blob/main/Milktea/LeetCode/Code/Java/_3583.java), [JavaScript](https://github.com/toan207/Code-And-Milktea/blob/main/Milktea/LeetCode/Code/JavaScript/3583.js)
