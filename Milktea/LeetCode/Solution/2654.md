> https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/

## Bài toán

```
You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:

Select an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.
Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.

The gcd of two integers is the greatest common divisor of the two integers.
```

## Tóm tắt

- Cho mảng **`nums`** gồm các số nguyên dương.
- Mỗi lần **thao tác** có thể chọn vị trí **`i`** **(0 ≤ i < n - 1)**, rồi thay nums[i] **hoặc** `nums[i+1]` bằng `gcd(nums[i], nums[i+1])`.
- Mục tiêu: đưa tất cả phần tử của mảng về **`1`** với số lần **thao tác** ít nhất.

## Nhận xét

* Nếu **`gcd`** của toàn mảng > 1 → không thể tạo ra 1 → kết quả là `-1`.
* Nếu trong mảng đã có phần tử `1`, ta có thể dùng chúng để biến các phần tử khác thành `1`.
  → Mỗi phần tử khác 1 cần đúng 1 lần thao tác.
  → Số thao tác = `n - count_1`.
* Nếu chưa có phần tử nào bằng 1, ta cần tìm **đoạn con ngắn nhất** có `gcd = 1`.
  * Giả sử độ dài đoạn đó là `len_min`.
  * Mất **`len_min - 1`** bước để tạo ra số 1 đầu tiên.
  * Sau đó cần thêm **`n - 1`** bước để lan 1 ra toàn mảng.
    → Tổng = `(len_min - 1) + (n - 1)`.

## Mã giả

```
n ← độ dài của nums

# B1: Đếm số phần tử bằng 1
count_1 ← 0
for i from 0 to n:
    if nums[i] == 1:
        count_1 <- count_1 + 1

if count_1 > 0:
    return n - count_1

# B2: Nếu chưa có phần tử 1 → tìm đoạn con nhỏ nhất có gcd = 1
min_len ← infinity
for i from 0 to n-1:
    current_gcd ← nums[i]
    for j from i+1 to n-1:
        current_gcd ← gcd(current_gcd, nums[j])
        if current_gcd == 1:
            min_len ← min(min_len, j - i)
            break

# B3: Tính toán trả về kết quả
if min_len == infinity:
    return -1
return min_len + n - 1
```

## Code giải

Python, Golang, Java, JavaScript
